<!doctype html>
<html lang="fr" data-theme="light">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Conversations — LoveNow</title>
  <meta name="description" content="Discute en temps réel avec les membres LoveNow."/>
  <link rel="stylesheet" href="/styles/tokens.css">
  <link rel="stylesheet" href="/styles/components.css">
  <script src="/js/features.js"></script>
  <script src="config.js"></script>
  <script defer src="/js/ui.js"></script>
  <style>
    *{box-sizing:border-box}
    html,body{margin:0;min-height:100%;background:var(--bg);color:var(--text);font-family:'Manrope',system-ui,sans-serif}
    a{color:inherit;text-decoration:none}

    main{padding-bottom:48px}

    .conversation-app{display:grid;grid-template-columns:minmax(260px,320px) minmax(0,1fr);gap:24px;margin:32px auto 64px;width:min(1180px,94vw)}
    @media(max-width:900px){.conversation-app{grid-template-columns:1fr;}}
    @media(max-width:900px){.sidebar{order:2}}

    .sidebar{background:rgba(255,255,255,0.82);border:1px solid rgba(255,255,255,0.9);border-radius:28px;box-shadow:0 28px 48px -34px rgba(47,22,52,0.35);overflow:hidden;display:flex;flex-direction:column}
    [data-theme="dark"] .sidebar{background:rgba(29,28,54,0.92);border-color:rgba(161,110,255,0.22);box-shadow:0 32px 60px -34px rgba(10,6,27,0.85)}

    .search{padding:22px;border-bottom:1px solid rgba(255,61,138,0.16);display:grid;gap:12px}
    .search input{width:100%}
    .search .muted{font-size:0.85rem}
    .search .tip{margin:6px 0 0}

    .list{flex:1;overflow:auto;padding:18px;display:grid;gap:12px}
    .conv{display:flex;gap:12px;align-items:center;padding:14px;border-radius:20px;background:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.6);box-shadow:0 18px 36px -28px rgba(47,22,52,0.35);cursor:pointer;transition:transform 150ms ease,box-shadow 150ms ease,background 150ms ease}
    .conv img{width:56px;height:56px;border-radius:18px;object-fit:cover;box-shadow:0 12px 24px -18px rgba(47,22,52,0.45)}
    .conv .meta{display:flex;flex-direction:column;gap:2px}
    .conv .meta .name{font-weight:600;font-size:1rem}
    .conv .meta .excerpt{font-size:0.9rem;color:var(--muted)}
    .conv:hover{transform:translateY(-2px);box-shadow:0 26px 42px -30px rgba(47,22,52,0.45);background:rgba(255,255,255,0.85)}
    .conv.active{background:linear-gradient(135deg,rgba(255,61,138,0.18),rgba(178,95,255,0.18));border-color:rgba(255,61,138,0.26)}

    .panel{background:rgba(255,255,255,0.88);border:1px solid rgba(255,255,255,0.9);border-radius:32px;box-shadow:0 30px 70px -36px rgba(47,22,52,0.35);display:flex;flex-direction:column;overflow:hidden}
    [data-theme="dark"] .panel{background:rgba(29,28,54,0.9);border-color:rgba(161,110,255,0.22);box-shadow:0 32px 68px -34px rgba(10,6,27,0.85)}

    .chatHead{display:flex;align-items:center;gap:14px;padding:22px;border-bottom:1px solid rgba(255,61,138,0.14)}
    .chatHead img{width:60px;height:60px;border-radius:22px;object-fit:cover;box-shadow:0 18px 36px -24px rgba(47,22,52,0.4)}
    .chatHead .muted{font-size:0.9rem}
    .chatName{font-weight:600;font-size:1.05rem}
    .chatSub{color:var(--muted);font-size:0.9rem}
    .spacer{flex:1}

    .chatMain{flex:1;overflow:auto;padding:28px;display:flex;flex-direction:column;gap:16px;background:linear-gradient(180deg,rgba(255,247,252,0.6),rgba(255,255,255,0.85))}
    [data-theme="dark"] .chatMain{background:linear-gradient(180deg,rgba(29,28,54,0.75),rgba(16,16,33,0.85))}

    .msg{max-width:min(70%,520px);padding:14px 16px;border-radius:20px;background:rgba(255,255,255,0.92);border:1px solid rgba(255,255,255,0.9);box-shadow:0 12px 30px -24px rgba(47,22,52,0.35);line-height:1.5}
    .mine{margin-left:auto;background:linear-gradient(135deg,var(--brand),var(--brand-2));color:#fff;border:none;box-shadow:0 18px 36px -28px rgba(255,61,138,0.7)}
    .stamp{font-size:0.8rem;color:var(--muted);margin-top:6px}

    .chatInput{display:grid;grid-template-columns:1fr auto;gap:14px;padding:22px;border-top:1px solid rgba(255,61,138,0.14);background:rgba(255,255,255,0.92)}
    .chatInput input{width:100%}
    .chatInput .btn{min-width:140px}

    .empty{padding:32px;text-align:center;color:var(--muted)}

    .badge--status{background:rgba(255,61,138,0.15);color:var(--brand)}
    [data-theme="dark"] .badge--status{background:rgba(161,110,255,0.18);color:var(--text)}

    .conversation-toolbar{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}

    .soft-btn{padding:0.5rem 0.85rem;border-radius:999px;background:rgba(255,61,138,0.12);color:var(--brand);font-weight:600;border:none;cursor:pointer}

    @media(max-width:900px){
      .chatHead{position:sticky;top:0;background:inherit;z-index:2}
      .chatMain{min-height:320px}
      .chatInput{position:sticky;bottom:0;background:inherit}
    }
  </style>
</head>
<body>
<header class="site-header">
  <div class="wrap nav-bar">
    <a class="brand" href="/" aria-label="LoveNow">
      <img src="/assets/brand/logo.svg" alt="Logo LoveNow" />
      <span>LoveNow</span>
    </a>
    <button class="nav-toggle" type="button" aria-expanded="false" aria-controls="primary-menu" data-toggle-nav>
      <span></span>
      <span class="sr-only">Ouvrir le menu</span>
    </button>
    <nav id="primary-menu" class="site-menu" aria-label="Navigation principale">
      <a href="/#discover">Découvrir</a>
      <a href="/matchmaking.html">Matching</a>
      <a href="/conversations.html" aria-current="page">Conversations</a>
      <a href="/profile.html">Mon profil</a>
      <a href="/settings.html">Paramètres</a>
      <div class="session-slot" id="header-session"></div>
    </nav>
    <button class="mode-toggle" type="button" data-toggle-theme aria-label="Basculer le mode d'affichage">
      <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
        <path d="M12 3a1 1 0 0 1 1 1v1.1a1 1 0 0 1-1 1h-.2a1 1 0 0 1-1-.8 3 3 0 0 0-2.9 2.9 1 1 0 0 1-.8 1H6a1 1 0 0 1-1-1A7 7 0 0 1 12 3Z" />
        <path d="M7 12a5 5 0 1 0 10 0 5 5 0 0 0-10 0Z" />
      </svg>
      <span>Mode</span>
    </button>
  </div>
</header>

<div id="verifyBanner" class="banner" hidden>
  <div><strong>E-mail non vérifié.</strong> Vérifie ton e-mail pour pouvoir envoyer des messages.</div>
  <div class="actions">
    <button id="btnResend" class="btn">Renvoyer le lien</button>
    <button id="btnRefresh" class="btn ghost">Rafraîchir</button>
  </div>
</div>

<main>
  <div class="conversation-app">
    <aside class="sidebar">
      <div class="search">
        <label for="emailStart" class="muted">Démarrer une discussion (par e-mail)</label>
        <div class="conversation-toolbar">
          <input id="emailStart" type="email" placeholder="ex. ami@exemple.com" autocomplete="off">
          <button id="btnStart" class="btn">OK</button>
        </div>
        <span id="devBadge" class="badge badge--dev" hidden>Mode test</span>
        <p class="muted tip">Astuce : tu peux aussi ouvrir <span class="badge">/conversations.html?startWith=UID</span></p>
      </div>
      <div id="convList" class="list" role="listbox" aria-label="Conversations"></div>
    </aside>

    <section class="panel">
      <div id="chatHead" class="chatHead" hidden>
        <img id="peerAvatar" src="" alt="Avatar de la conversation">
        <div>
          <div id="peerName" class="chatName">Sélectionne une conversation</div>
          <div id="peerCity" class="chatSub"></div>
        </div>
        <span class="spacer"></span>
        <span id="chatStatus" class="badge badge--status">Temps réel</span>
      </div>

      <div id="emptyChat" class="empty">Aucune discussion ouverte. Choisis une conversation à gauche ou lance une discussion.</div>
      <div id="chatMain" class="chatMain" hidden></div>

      <div id="chatInput" class="chatInput" hidden>
        <input id="msg" type="text" placeholder="Écrire un message…" maxlength="2000" autocomplete="off">
        <button id="btnSend" class="btn">Envoyer</button>
      </div>
    </section>
  </div>
</main>

<footer>
  <div class="wrap footer-card">
    <small>© LoveNow — Conversations sécurisées</small>
    <div class="footer-links">
      <a href="/privacy.html">Confidentialité</a>
      <a href="/cgu.html">CGU</a>
      <a href="/profile.html">Mon profil</a>
    </div>
  </div>
</footer>

<script type="module">
  import {
    setupFirebase,
    renderVerifyBanner,
    applySessionToHeader,
    safeSignOut,
    ensureUserDocuments,
    loadUserProfile,
    isDevBypassEnabled,
    getPairId,
  } from '/js/app-core.js';

  const state = {
    currentUser: null,
    devBypass: isDevBypassEnabled(),
    activeConvId: null,
    activePeerUid: null,
    unsubConv: null,
    unsubMessages: null,
    profileCache: new Map(),
  };

  const $ = (selector) => document.querySelector(selector);
  const convList = $('#convList');
  const chatHead = $('#chatHead');
  const emptyChat = $('#emptyChat');
  const chatMain = $('#chatMain');
  const chatInput = $('#chatInput');
  const msgInput = $('#msg');
  const btnSend = $('#btnSend');
  const btnStart = $('#btnStart');
  const emailStart = $('#emailStart');
  const verifyBanner = $('#verifyBanner');
  const btnResend = $('#btnResend');
  const btnRefresh = $('#btnRefresh');
  const headerSlot = document.getElementById('header-session');
  const peerAvatar = $('#peerAvatar');
  const peerName = $('#peerName');
  const peerCity = $('#peerCity');
  const chatStatus = $('#chatStatus');
  const devBadge = $('#devBadge');

  const fmtTime = (date) => (date ? new Intl.DateTimeFormat('fr-FR', { hour: '2-digit', minute: '2-digit' }).format(date) : '');

  const showDevBadge = () => {
    if (!devBadge) return;
    devBadge.hidden = !state.devBypass;
  };

  const clearConversation = () => {
    chatHead.hidden = true;
    chatMain.hidden = true;
    chatMain.innerHTML = '';
    chatInput.hidden = true;
    emptyChat.hidden = false;
    state.activeConvId = null;
    state.activePeerUid = null;
    if (state.unsubMessages) {
      state.unsubMessages();
      state.unsubMessages = null;
    }
    setSendEnabled(false);
    if (chatStatus) chatStatus.textContent = 'Sélectionne une conversation';
    [...convList.querySelectorAll('.conv')].forEach((node) => node.classList.remove('active'));
  };

  const setSendEnabled = (canSend) => {
    if (btnSend) btnSend.disabled = !canSend;
    if (msgInput) msgInput.disabled = !canSend;
    if (chatStatus) {
      chatStatus.textContent = canSend ? 'Temps réel' : 'Bloqué (e-mail non vérifié)';
    }
  };

  const getProfile = async (uid, db, firestoreModule) => {
    if (state.profileCache.has(uid)) return state.profileCache.get(uid);
    const data = await loadUserProfile(db, firestoreModule, uid);
    state.profileCache.set(uid, data || {});
    return data || {};
  };

  const renderConversationList = (items, db, firestoreModule) => {
    convList.innerHTML = '';
    if (!items.length) {
      const emptyNode = document.createElement('div');
      emptyNode.className = 'empty';
      emptyNode.textContent = 'Pas encore de conversations. Lance la première via le champ e-mail.';
      convList.appendChild(emptyNode);
      return;
    }
    items.forEach((conv) => {
      const node = document.createElement('div');
      node.className = 'conv';
      node.dataset.cid = conv.id;
      node.dataset.peer = conv.peerUid;
      node.setAttribute('role', 'option');
      const lastText = (conv.lastMessageText || '').slice(0, 80);
      const updated = conv.lastMessageAt || conv.updatedAt || conv.createdAt;
      const timeLabel = updated ? fmtTime(updated.toDate ? updated.toDate() : updated) : '';
      const avatar = conv.peer?.photoURL || 'https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=200&auto=format&fit=crop';
      const name = conv.peer?.name || conv.peer?.displayName || 'Utilisateur';
      node.innerHTML = `
        <img src="${avatar}" alt="Photo de ${name}">
        <div class="meta">
          <div class="name">${name}</div>
          <div class="excerpt">${lastText || '—'} ${timeLabel ? `· ${timeLabel}` : ''}</div>
        </div>
      `;
      node.addEventListener('click', () => openConversation(conv.id, conv.peerUid, db, firestoreModule));
      convList.appendChild(node);
    });
    [...convList.querySelectorAll('.conv')].forEach((node) => {
      if (node.dataset.cid === state.activeConvId) node.classList.add('active');
    });
  };

  const openConversation = async (convId, peerUid, db, firestoreModule) => {
    if (!state.currentUser) return;
    if (state.unsubMessages) {
      state.unsubMessages();
      state.unsubMessages = null;
    }
    state.activeConvId = convId;
    state.activePeerUid = peerUid;

    const peer = await getProfile(peerUid, db, firestoreModule);
    peerAvatar.src = peer.photoURL || 'https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=200&auto=format&fit=crop';
    peerName.textContent = peer.name || peer.displayName || 'Utilisateur';
    peerCity.textContent = peer.city ? `📍 ${peer.city}` : '';

    chatHead.hidden = false;
    emptyChat.hidden = true;
    chatMain.hidden = false;
    chatMain.innerHTML = '';
    chatInput.hidden = false;

    const canSend = state.currentUser.emailVerified || state.devBypass;
    setSendEnabled(canSend);

    const { doc, collection, query, orderBy, onSnapshot, limit } = firestoreModule;
    const convRef = doc(db, 'conversations', convId);
    const messagesQuery = query(collection(convRef, 'messages'), orderBy('createdAt', 'asc'), limit(500));
    state.unsubMessages = onSnapshot(messagesQuery, (snapshot) => {
      chatMain.innerHTML = '';
      snapshot.forEach((msgDoc) => {
        const message = msgDoc.data();
        const me = message.from === state.currentUser.uid;
        const node = document.createElement('div');
        node.className = `msg${me ? ' mine' : ''}`;
        const when = message.createdAt?.toDate ? fmtTime(message.createdAt.toDate()) : '';
        node.innerHTML = `
          <div>${(message.text || '').replace(/</g, '&lt;')}</div>
          <div class="stamp">${when}</div>
        `;
        chatMain.appendChild(node);
      });
      chatMain.scrollTop = chatMain.scrollHeight;
    }, (error) => console.error('Messages watch error', error));

    [...convList.querySelectorAll('.conv')].forEach((node) => {
      if (node.dataset.cid === convId) node.classList.add('active');
      else node.classList.remove('active');
    });
  };

  const ensureConversationWith = async (peerUid, db, firestoreModule) => {
    if (!state.currentUser) throw new Error('Utilisateur non connecté');
    if (!peerUid || peerUid === state.currentUser.uid) throw new Error('UID cible invalide');
    const { doc, getDoc, setDoc, serverTimestamp } = firestoreModule;
    const convId = getPairId(state.currentUser.uid, peerUid);
    const convRef = doc(db, 'conversations', convId);
    const existing = await getDoc(convRef);
    if (existing.exists()) return convId;
    await setDoc(convRef, {
      members: [state.currentUser.uid, peerUid],
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      lastMessageText: '',
      lastMessageAt: null,
    });
    return convId;
  };

  const sendMessage = async (db, firestoreModule) => {
    const text = (msgInput.value || '').trim();
    if (!text) return;
    if (!state.activeConvId || !state.activePeerUid) {
      alert('Choisis une conversation d’abord.');
      return;
    }
    if (!state.currentUser) return;
    if (!state.currentUser.emailVerified && !state.devBypass) {
      verifyBanner.hidden = false;
      alert('Vérifie ton e-mail pour envoyer des messages.');
      return;
    }

    setSendEnabled(false);
    const { doc, collection, addDoc, serverTimestamp, setDoc } = firestoreModule;
    try {
      const convRef = doc(db, 'conversations', state.activeConvId);
      await addDoc(collection(convRef, 'messages'), {
        from: state.currentUser.uid,
        text,
        createdAt: serverTimestamp(),
      });
      await setDoc(convRef, {
        lastMessageText: text,
        lastMessageAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      }, { merge: true });
      msgInput.value = '';
      msgInput.focus();
    } catch (error) {
      console.error('send message failed', error);
      alert('Impossible d’envoyer le message pour le moment.');
    } finally {
      const canSend = state.currentUser.emailVerified || state.devBypass;
      setSendEnabled(canSend);
    }
  };

  const startConversationByEmail = async (db, firestoreModule) => {
    const email = (emailStart.value || '').trim().toLowerCase();
    if (!email) return;
    if (!state.currentUser) return;
    const { collection, query, where, limit, getDocs } = firestoreModule;
    let peerUid = null;
    const userQuery = query(collection(db, 'users'), where('email', '==', email), limit(1));
    const snap = await getDocs(userQuery);
    if (!snap.empty) {
      peerUid = snap.docs[0].id;
    } else {
      const legacyQuery = query(collection(db, 'profiles'), where('email', '==', email), limit(1));
      const legacySnap = await getDocs(legacyQuery);
      if (!legacySnap.empty) {
        peerUid = legacySnap.docs[0].id;
      }
    }
    if (!peerUid) {
      alert('Aucun profil trouvé pour cet e-mail.');
      return;
    }
    const convId = await ensureConversationWith(peerUid, db, firestoreModule);
    await openConversation(convId, peerUid, db, firestoreModule);
    history.replaceState({}, '', `?cid=${encodeURIComponent(convId)}`);
  };

  const watchConversations = (db, firestoreModule) => {
    if (state.unsubConv) {
      state.unsubConv();
      state.unsubConv = null;
    }
    const { collection, query, where, onSnapshot } = firestoreModule;
    const convQuery = query(collection(db, 'conversations'), where('members', 'array-contains', state.currentUser.uid));
    state.unsubConv = onSnapshot(convQuery, async (snapshot) => {
      const items = [];
      for (const docSnap of snapshot.docs) {
        const data = docSnap.data();
        const peerUid = (data.members || []).find((id) => id !== state.currentUser.uid);
        if (!peerUid) continue;
        const peer = await getProfile(peerUid, db, firestoreModule);
        items.push({
          id: docSnap.id,
          ...data,
          peerUid,
          peer,
        });
      }
      items.sort((a, b) => {
        const ta = a.lastMessageAt?.toMillis ? a.lastMessageAt.toMillis() : (a.updatedAt?.toMillis ? a.updatedAt.toMillis() : 0);
        const tb = b.lastMessageAt?.toMillis ? b.lastMessageAt.toMillis() : (b.updatedAt?.toMillis ? b.updatedAt.toMillis() : 0);
        return tb - ta;
      });
      renderConversationList(items, db, firestoreModule);
    }, (error) => console.error('Conversations watch error', error));
  };

  const hydrateFromUrl = async (db, firestoreModule) => {
    const params = new URLSearchParams(window.location.search);
    const startWith = params.get('startWith');
    const cid = params.get('cid');
    if (startWith) {
      try {
        const convId = await ensureConversationWith(startWith, db, firestoreModule);
        await openConversation(convId, startWith, db, firestoreModule);
        history.replaceState({}, '', `?cid=${encodeURIComponent(convId)}`);
      } catch (error) {
        console.error('startWith failed', error);
      }
    } else if (cid) {
      const { doc, getDoc } = firestoreModule;
      try {
        const convRef = doc(db, 'conversations', cid);
        const snap = await getDoc(convRef);
        if (snap.exists()) {
          const peerUid = (snap.data().members || []).find((id) => id !== state.currentUser.uid);
          if (peerUid) await openConversation(cid, peerUid, db, firestoreModule);
        }
      } catch (error) {
        console.error('cid open failed', error);
      }
    }
  };

  (async () => {
    const { auth, db, authModule, firestoreModule } = await setupFirebase();
    const {
      onAuthStateChanged,
      signOut,
      sendEmailVerification,
      reload,
    } = authModule;

    renderVerifyBanner({
      banner: verifyBanner,
      resendBtn: btnResend,
      refreshBtn: btnRefresh,
      onResend: async () => {
        if (!auth.currentUser) return;
        await sendEmailVerification(auth.currentUser);
        alert('Lien de vérification envoyé ✅');
      },
      onRefresh: async () => {
        if (!auth.currentUser) return;
        await reload(auth.currentUser);
        if (auth.currentUser.emailVerified || state.devBypass) {
          verifyBanner.hidden = true;
        }
      },
    });

    showDevBadge();

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        if (state.unsubConv) state.unsubConv();
        if (state.unsubMessages) state.unsubMessages();
        window.location.href = '/login.html#log_in';
        return;
      }
      state.currentUser = user;
      state.profileCache.clear();
      clearConversation();
      await ensureUserDocuments(db, firestoreModule, user);
      applySessionToHeader(headerSlot, user, {
        onSignOutClick: (event) => safeSignOut(auth, signOut, event?.currentTarget),
      });
      verifyBanner.hidden = user.emailVerified || state.devBypass;
      setSendEnabled(user.emailVerified || state.devBypass);
      watchConversations(db, firestoreModule);
      await hydrateFromUrl(db, firestoreModule);
    });

    btnSend?.addEventListener('click', () => sendMessage(db, firestoreModule));
    msgInput?.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendMessage(db, firestoreModule);
      }
    });
    btnStart?.addEventListener('click', () => startConversationByEmail(db, firestoreModule));
  })();
</script>
<script>loadCrispIfEnabled();</script>
</body>
</html>